---
layout: keynote
title: "笔试总结（HTTP(S)/虚拟内存/xhr）"
subtitle: "记录-复习"
author: "cici"
tags:
  - JavaScript
---

同花顺的笔试完虐我这种渣渣，没有选择填空，只有问答和编程题，且大部分C++/JAVA,完全懵逼，

陌陌的算法题60分，也懵到题目都搞不清楚
完美世界的比较均衡，选择很基础，编程题也不难，只是我的编译一直不通过很伤
下面总结一下不太清楚的知识点

## 1.虚拟内存
虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

虚拟内存是Windows

为作为内存使用的一部分硬盘空间，可以解决执行的程序占用内存很大或很多，则会导致内存消耗殆尽的问题，若计算机运行程序或操作所需的随机存储器不足时，则 Windows 会用虚拟存储器进行补偿。但是，计算机从RAM读取数据的速率要比从硬盘读取数据的速率快，因而扩增RAM容量是最佳选择。

虚存的大小要同时满足2个条件：

1. 虚存的大小 ≤ 内存容量和外存容量之和。
2. 虚存的大小 ≤ 计算机的地址位数能容纳的最大容量

因为计算机所支持的最大内存是由该计算机的地址位数决定的，也就是计算机的最大寻址能力。例如，32位机的寻址能力为2的32次方，大约为4G。所以虚拟内存的大小也受计算机地址位数的限制。

## 2.XmlHttpRequest对象的状态
readystate是一个只读属性，表示XHR对象当前的状态

0. 对应常量UNSENT，表示XMLHttpRequest实例已经生成，但是open()方法还没有被调用。
1. 对应常量OPENED，表示send()方法还没有被调用，仍然可以使用setRequestHeader()，设定HTTP请求的头信息。
2. 对应常量HEADERS_RECEIVED，表示send()方法已经执行，并且头信息和状态码已经收到。
3. 对应常量LOADING，表示正在接收服务器传来的body部分的数据，如果responseType属性是text或者空字符串，responseText就会包含已经收到的部分信息。
4. 对应常量DONE，表示服务器数据已经完全接收，或者本次接收已经失败了。

state:表示请求所得的HTTP状态

code | meaning | state
---|---|---
200 | OK|访问正常
301| Moved Permanently|永久移动
302|Move temporarily|暂时移动
304| Not Modified|未修改
307| Temporary Redirect|暂时重定向
401|Unauthorized|未授权
403|Forbidden|禁止访问
404| Not Found|未发现指定网址
500| Internal Server Error|服务器发生错误

## 3. HTTP部分知识详解：

Http状态码

3.HTTP协议

3.1 HTTP1.1与1.0相比的优化：

- 缓存处理<br>
header里引入了更多的缓存控制策略
带宽优化及网络连接的使用
在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206

- 错误通知的管理<br>
新增了24个错误状态响应码

- Host头处理<br>
请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）

- 长连接<br>
支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟

3.2 HTTPS与HTTP的一些区别

1. HTTPS协议需要到CA申请证书
2. HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
4. HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题

3.3 SPDY：HTTP1.x的优化

- 降低延迟<br>

针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率

- 请求优先级<br>

多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应

- header压缩<br>

前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量

- 基于HTTPS的加密协议传输<br>
大大提高了传输数据的可靠性

- 服务端推送<br>
采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了

3.4 HTTP2.0性能惊人

HTTP2.0可以说是SPDY的升级版

HTTP2.0和SPDY的区别：

- HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS
- HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE

HTTP2.0和HTTP1.X相比的新特性：

- 新的二进制格式<br>

HTTP1.x的解析是基于文本，HTTP2.0的协议解析采用二进制格式，实现方便且健壮
- 多路复用

- header压缩

- 服务端推送

HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？

HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；

HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；

HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；