---
layout: post
title: "JS——正则详解"
subtitle: "JS——RegExp"
author: "cici"
header-style: text
tags:
  - JavaScript
  - RegExp
---

Update: 文章内容摘自阮一峰大大—[RegExp对象](http://javascript.ruanyifeng.com/stdlib/regexp.html)，总结一下方便自己记忆

---

## 1.正则匹配规则

- 字面量字符串

  /dog/ 匹配 ‘dog’

- 元字符

  点字符（.） 匹配 除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。
  位置字符（^ / $） ^/$ 表示字符串开始/结束的位置
  选择符（|） 表示或关系，即`cat|dog`表示匹配cat或dog。选择符会包括它前后的多个字符，比如`/ab|cd/`指的是匹配ab或者cd，而不是指匹配b或者c。如果想修改这个行为，可以使用圆括号，即`/a(b|c)d/`

- 转义字符

  正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配加号，就要写成+。
  正则模式中，需要用斜杠转义的，一共有12个字符： `^`、`.`、`[`、`$`、`(`、`)`、`|`、`*`、`+`、`?`、`{`和`\`。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。

- 特殊字符

  -------- | -----
  `\cX`| 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。
  `[\b]`| 匹配退格键(U+0008)，不要与\b混淆。
  `\n`| 匹配换行键。
  `\r`| 匹配回车键。
  `\t`| 匹配制表符tab（U+0009）。
  `\v`| 匹配垂直制表符（U+000B）。
  `\f`| 匹配换页符（U+000C）。
  `\0`| 匹配null字符（U+0000）。
  `\xhh`| 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。
  `\uhhhh`| 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的unicode字符。

- 字符类

  字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。
  - 1.脱字符（^）
  如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，`[^xyz]`表示除了x、y、z之外都可以匹配。
  如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符，而点号（.）是不包括换行符的
  - 2.连字符（-）
  某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，`[abc]`可以写成`[a-c]`，`[0123456789]`可以写成`[0-9]`，同理`[A-Z]`表示26个大写字母。

  **注意：`[1-31]`，不代表1到31，只代表1到3。**

- 预定义模式

  -------- | -----
  `\d`| 匹配0-9之间的任一数字，相当于[0-9]。
  `\D`| 匹配所有0-9以外的字符，相当于[^0-9]。
  `\w`| 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。
  `\W`| 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。
  `\s`| 匹配空格（包括制表符、空格符、断行符等），相等于[\t\r\n\v\f]。
  `\S`| 匹配非空格的字符，相当于[^\t\r\n\v\f]。
  `\b`| 匹配词的边界。
  `\B`| 匹配非词边界，即在词的内部。
  
- 重复类

  模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。

- 量词类

  - `?`问号表示某个模式出现0次或1次，等同于**{0, 1}**。

  - `*`星号表示某个模式出现0次或多次，等同于**{0,}**。

  - `+`加号表示某个模式出现1次或多次，等同于**{1,}**。

- 贪婪模式

   默认情况下是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。
   如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。
  ```javascript
    //贪婪模式
    var s = 'aaa';
    s.match(/a+/) // ["aaa"]
    //非贪婪模式
    var s = 'aaa';
    s.match(/a+?/) // ["a"]
  ```

  `*?`：表示某个模式出现0次或多次，匹配时采用非贪婪模式。

  `+?`：表示某个模式出现1次或多次，匹配时采用非贪婪模式。

- 修饰符

  修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。
  修饰符可以单个使用，也可以多个一起使用。

  - **g修饰符**

  默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。

  - **i修饰符**

  默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。

  - **m修饰符**

  m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。

- 组匹配

  正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。

```javascript
    var m = 'abcabc'.match(/(.)b(.)/);
    m
    // ['abc', 'a', 'c']
  ```

  上面代码中，正则表达式/(.)b(.)/一共使用两个括号，第一个括号捕获a，第二个括号捕获c。

  **注意:使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。**

  在正则表达式内部，可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。

  ```javascript
    /(.)b(.)\1b\2/.test("abcabc") // true
    /y(..)(.)\2\1/.test('yabccab') // true
  ```

  上面的第一行代码中，\1表示前一个括号匹配的内容（即“a”），\2表示第二个括号匹配的内容（即“b”）。

  ```javascript
    /y((..)\2)\1/.test('yabababab') // true   
    // 括号还可以嵌套，此时\1指向外层括号，\2指向内层括号。
  ```

  **非捕获组**
  
  `(?:x)` 称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。

  ```javascript
    var m = 'abc'.match(/(?:.)b(.)/);
    m // ["abc", "c"]
  ```

  上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。
  
  **先行断言**
  
  `x(?=y)` 称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。

  ```javascript
    var m = 'abc'.match(/(?:.)b(.)/);
    m // ["abc", "c"]
  ```
  **先行否定断言**

  `x(?!y)` 称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。

  ```javascript
    /\d+(?!\.)/.exec('3.14')
    // ["14"]
  ```

------

## 2.正则表达式

  新建正则表达式有两种方法。
  一种是使用字面量，以斜杠表示开始和结束。
  另一种是使用 RegExp 构造函数。

  ```javascript
  var regex = /xyz/;
  var regex = new RegExp('xyz');
  ```

  上面两种写法是等价的，都新建了一个内容为xyz的正则表达式对象。它们的主要区别是，第一种方法在编译时新建正则表达式，第二种方法在运行时新建正则表达式。
  正则对象生成以后，有两种使用方式：

  正则对象的方法：将字符串作为参数，比如**regex.test(string)**

  字符串对象的方法：将正则对象作为参数，比如**string.match(regex)**

  - 正则对象的属性
  
  属性分两类
  一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置。

  **ignoreCase**：返回一个布尔值，表示是否设置了i修饰符，该属性只读。

  **global**：返回一个布尔值，表示是否设置了g修饰符，该属性只读。

  **multiline**：返回一个布尔值，表示是否设置了m修饰符，该属性只读。

  一类与修饰符无关的属性，主要是下面两个。

  **lastIndex**：返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。

  **source**：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。

  - 正则对象的方法

  1.test()

  正则对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。

  ```javascript
  /cat/.test('cats and dogs') // true
  ```

  如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配,还可以通过正则对象的lastIndex属性指定开始搜索的位置。
  lastIndex属性只对同一个正则表达式有效.

  ```javascript
  var count = 0;
  while (/a/g.test('babaa')) count++;
  ```

  上面代码会导致无限循环，因为while循环的每次匹配条件都是一个新的正则表达式，导致lastIndex属性总是等于0。

  ```javascript
  new RegExp('').test('abc')
  // true
  // 如果正则模式是一个空字符串，则匹配所有字符串。
  ```

  2.exec()

  正则对象的exec方法，可以返回匹配结果。如果发现匹配，就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null。

  ```javascript
  var s = '_x_x';
  var r1 = /x/;
  var r2 = /y/;

  r1.exec(s); // ["x"]
  r2.exec(s); // null
  ```

  如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。

  exec方法的返回数组还包含以下两个属性：

  **input**：整个原字符串。

  **index**：整个模式匹配成功的开始位置（从0开始计数）。  
  
  如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始.

  ```javascript
  var r = /a(b+)a/g;

  var a1 = r.exec('_abbba_aba_');
  a1 // ['abbba', 'bbb']
  a1.index // 1
  r.lastIndex // 6

  var a2 = r.exec('_abbba_aba_');
  a2 // ['aba', 'b']
  a2.index // 7
  r.lastIndex // 10

  var a3 = r.exec('_abbba_aba_');
  a3 // null
  a3.index // TypeError: Cannot read property 'index' of null
  r.lastIndex // 0

  var a4 = r.exec('_abbba_aba_');
  a4 // ['abbba', 'bbb']
  a4.index // 1
  r.lastIndex // 6

  ```

  当第三次匹配结束以后，整个字符串已经到达尾部，正则对象的lastIndex属性重置为0，意味着第四次匹配将从头开始。
  利用g修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。

  ```javascript
  var r = /a(b+)a/g;
  var s = '_abbba_aba_';

  while(true) {
    var match = r.exec(s);
    if (!match) break;
    console.log(match[1]);
  }
  // bbb
  // b
  ```

  如果正则对象是一个空字符串，则exec方法会匹配成功，但返回的也是空字符串。

------

## 3.字符串对象的方法

  -------- | -----
  `match()`| 返回一个数组，成员是所有匹配的子字符串。
  `search()`| 按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。
  `replace()`| 按照给定的正则表达式进行替换，返回替换后的字符串。
  `split()`| 按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。

  - **String.prototype.match()**

  字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。

  如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。

  设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。

  - **String.prototype.search()**

  字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。

  正则表达式使用g修饰符之后，使用lastIndex属性指定开始匹配的位置，结果无效，还是从字符串的第一个字符开始匹配。

  - **String.prototype.replace()**

  字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容。

  搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。

  replace方法的一个应用，就是消除字符串首尾两端的空格。
  
  ```javascript
  var str = '  #id div.class  ';
  str.replace(/^\s+|\s+$/g, '')
  // "#id div.class"
  ```

  replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。

  -------- | -----
   $&| 指代匹配的子字符串。
   $`| 指代匹配结果前面的文本。
   $'| 指代匹配结果后面的文本。
   $n| 指代匹配成功的第n组内容，n是从1开始的自然数。
   $$| 指代美元符号$。

  replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。
  作为replace方法第二个参数的替换函数，可以接受多个参数。第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。 

  - **String.prototype.split()**
  
  字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。
  该方法接受两个参数，第一个参数是分隔规则，第二个参数是返回数组的最大成员数。